import * as base from "./base.js";
import * as sudoku from "../sudoku.js";
import * as test_util from "./test_util.js";
import { eliminateFromCages } from "./cages.js";
QUnit.module("strategies/cages");
QUnit.test("killer sudoku", (assert) => {
    // https://en.wikipedia.org/wiki/Killer_sudoku
    const settings = base.processSettings({
        // prettier-ignore
        cages: [
            { members: [[0, 0], [0, 1]], sum: 3 },
            { members: [[0, 2], [0, 3], [0, 4]], sum: 15 },
            { members: [[0, 5], [1, 5], [1, 4], [2, 4]], sum: 22 },
            { members: [[0, 6], [1, 6]], sum: 4 },
            { members: [[0, 7], [1, 7]], sum: 16 },
            { members: [[0, 8], [1, 8], [2, 8], [3, 8]], sum: 15 },
            { members: [[1, 0], [2, 0], [2, 1], [1, 1]], sum: 25 },
            { members: [[1, 2], [1, 3]], sum: 17 },
            { members: [[2, 2], [2, 3], [3, 3]], sum: 9 },
            { members: [[2, 5], [3, 5], [4, 5]], sum: 8 },
            { members: [[2, 7], [2, 6], [3, 6]], sum: 20 },
            { members: [[3, 0], [4, 0]], sum: 6 },
            { members: [[3, 2], [3, 1]], sum: 14 },
            { members: [[3, 4], [4, 4], [5, 4]], sum: 17 },
            { members: [[3, 7], [4, 7], [4, 6]], sum: 17 },
            { members: [[4, 1], [5, 1], [4, 2]], sum: 13 },
            { members: [[4, 3], [5, 3], [6, 3]], sum: 20 },
            { members: [[4, 8], [5, 8]], sum: 12 },
            { members: [[5, 0], [6, 0], [7, 0], [8, 0]], sum: 27 },
            { members: [[5, 2], [6, 2], [6, 1]], sum: 6 },
            { members: [[5, 5], [6, 5], [6, 6]], sum: 20 },
            { members: [[5, 7], [5, 6]], sum: 6 },
            { members: [[6, 4], [7, 4], [7, 3], [8, 3]], sum: 10 },
            { members: [[6, 7], [7, 7], [7, 8], [6, 8]], sum: 14 },
            { members: [[7, 1], [8, 1]], sum: 8 },
            { members: [[7, 2], [8, 2]], sum: 16 },
            { members: [[7, 5], [7, 6]], sum: 15 },
            { members: [[8, 4], [8, 5], [8, 6]], sum: 13 },
            { members: [[8, 7], [8, 8]], sum: 17 },
        ],
    });
    const [solution, steps] = test_util.solve(settings, sudoku.emptyBoard());
    assert.equal(steps, 5);
    assert.equal(sudoku.dump(solution), `\
215 647 398
368 952 174
794 381 652

586 274 931
142 593 867
973 816 425

821 739 546
659 428 713
437 165 289`);
});
QUnit.test("eliminate cage with sum", (assert) => {
    const settings = base.processSettings({
        cages: [
            {
                members: [
                    [0, 0],
                    [0, 1],
                    [0, 2],
                ],
                sum: 6,
            },
        ],
    });
    const board = sudoku.emptyBoard();
    const next = sudoku.clone(board);
    eliminateFromCages(settings, board, next);
    assert.equal(sudoku.dump(next, true), `\
[123      ][123      ][123      ] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]

[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]

[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]`);
});
QUnit.test("eliminate cage with sum and starting restrictions", (assert) => {
    const settings = base.processSettings({
        cages: [
            {
                members: [
                    [0, 0],
                    [0, 1],
                    [0, 2],
                ],
                sum: 6,
            },
        ],
    });
    const board = sudoku.emptyBoard();
    board[0][0] = 1;
    const next = sudoku.clone(board);
    eliminateFromCages(settings, board, next);
    assert.equal(sudoku.dump(next, true), `\
[1        ][ 23      ][ 23      ] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]

[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]

[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]`);
});
QUnit.test("worst case cage", (assert) => {
    const firstRow = [];
    for (let i = 0; i < 9; i++) {
        firstRow.push([0, i]);
    }
    const settings = base.processSettings({
        cages: [
            {
                members: firstRow,
                sum: 45,
            },
        ],
    });
    const board = sudoku.emptyBoard();
    const next = sudoku.clone(board);
    eliminateFromCages(settings, board, next);
    assert.ok(sudoku.areBoardsEqual(board, next));
});
QUnit.test("cage missing one digit", (assert) => {
    const firstRow = [];
    for (let i = 0; i < 8; i++) {
        firstRow.push([0, i]);
    }
    const settings = base.processSettings({
        cages: [
            {
                members: firstRow,
                sum: 44,
            },
        ],
    });
    const board = sudoku.emptyBoard();
    const next = sudoku.clone(board);
    eliminateFromCages(settings, board, next);
    assert.equal(sudoku.dump(next, true), `\
[ 23456789][ 23456789][ 23456789] [ 23456789][ 23456789][ 23456789] [ 23456789][ 23456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]

[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]

[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]
[123456789][123456789][123456789] [123456789][123456789][123456789] [123456789][123456789][123456789]`);
});
